# Stake Value DB Query and Processing

Stake Value Calculation relies on the query results pre-generated by:

1. [Vote Registration Query](vote_registration_query.md)
2. [Snapshot Table Query](snapshot_table_query.md)

## Current Process

1. Get all latest and relevant vote registrations.
2. Get the results from the Snapshot Table Query.
3. For each registration:
   1. Get the stake address
   2. Calculate the voting power of the stake address.
      1. Query the `Snapshot Table` created above with:

        ```sql
        SELECT utxo_snapshot.value FROM utxo_snapshot WHERE stake_credential = registration_stake_credential
        ```

      2. For each value returned by the query, add it to an accumulated value.
      3. Return the accumulated value
   3. save the voting power with the registration
4. Create an output JSON file from the registrations, with their voting power.

## Reasons why this is not optimal

1. Every registration requires an individual transaction to the database to
   search a very large table, which was slow to create, for relatively few
   values.
2. The database can accumulate values, so there is no reason to return the
   individual records, in this process just to accumulate them.
3. The registrations are stored in a VEC which can not be easily indexed, but it
   can be iterated.

## Suggested optimized procedure, including weighting for CIP-36

1. Create a registration hashmap.
2. Query the latest registrations using the optimized query, and add them to the
   registration hash map, with the stake credential as the key, and with an
   extra field for staked value and set it initially to 0.
3. Start the optimized Snapshot Table query, and get the cursor for reading results.
4. For each result:
   1. If the Stake Credential is in the hashmap:
      2. Add the value of the transaction to the registration record.
5. Make a voting power hashmap.
6. For each entry in the registration hashmap:
   1. Get the list of Delegations and weights.
   2. Sum the weights.
   3. Integer divide the Stake Credential by the total weight.
   4. For each Delegation:
      1. Lookup the delegation in the voting power hashmap.
      2. If it doesn't exist, create it and assign voting power according to the
         relative weight.
      3. If it does, add the relative weight of voting power to the delegation record.
      4. If its the last delegation record, also add any residual voting power
         that could not be integer divided by the weights.
7. Produce an output json file of the same format as the original file, where
   each record is the voting power of each unique delegation address.

Note: I am not 100% sure how the delegation output should work, how the file is
consumed and what its expectations work. The procedure should be fully OK up to
step 6. There may need to be adjustments to suit the required output for step 7.
